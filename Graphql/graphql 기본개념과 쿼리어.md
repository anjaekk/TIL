
## Graphql의 개념
`graphql`은 2015년 페이스북에서 공개한 API를 만들 때 사용할 수 있는 쿼리언어이다. 쿼리언어이지만 `SQL`과는 사용환경이 다르다. 

- SQL: 데이터에 보내는 쿼리언어
- Graphql: 데이터베이스용 쿼리의 개념으로 만들어진 API에 보내는 인터넷용 쿼리언어

데이터 전송은 `RPC → SOAP → REST` 순으로 발전해왔는데 REST의 단점들을 보완하며 API를 좀더 효율적으로 개발하기위해 도입되었다. `Graphql`의 도입이유를 더 쉽게 이해하기위해 `REST`의 단점을 알아보자. `REST`의 단점을 보완하기 위해 등장하긴 했지만 그렇다고해서 `graphql`이 무조건 `REST`보다 낫냐를 두고 본다면 꼭 그렇지만은 않기 때문에 `REST`의 대체재는 아니라고 하고싶다.~~_(개인적으로는 효율적인 부분도 있지만 코드작성시 REST 보다 복잡하고 추상적인 느낌이 들었음..)_~~

## Graphql 사용 이유
### REST의 단점

**1. Overfetching**
    
오버페칭은 필요하지 않은 데이터까지 모두 불러오는 것을 말한다. `REST API`에서 `GET`메서드로 `members/1` URL을 통해 가져온다면 필요하지않은 key값까지 불러오게되지만 `graphql`에서는 필요한 필드만 정희하여 쿼리를 작성할 수 있다.
    
**2. Underfetching**
    
언더페칭은 데이터를 요청하고 그에 관련한 또 다른 데이터를 추가로 요청하는 것을 말한다. 예를 들어 판매중인 아이스크림의 데이터를 요청하고 또 각각의 아이스크림의 맛들까지 요청하는 경우다.(비유가 좀 그런가..) 그 아이스크림의 각각 라우트에서 또 다른 데이터를 가져와야 하기 때문에 아이스크림의 수만큼 요청을 더 보내야하고 거기서 사용할 데이터는 막상 극히 일부라면 데이터를 과도하게 요청하여 그만큼의 리소스를 더 사용하게된다. `graphql`에서는 쿼리를 중첩으로 정의하여 한번에 필요한 데이터만 요청할 수 있다. 
    
**3. 엔드포인트 관리**
    
`REST API`는 클라이언트의 변경이 생길 때마다 엔드포인트를 새로 만들어야 한다. 하지만 `graphql`은 단일 엔드포인트가 게이트웨이가 되므로 계속해서 엔드포인트를 만들 필요가 없다. 
    

이외에도 REST API에서는 명세를 직접 작성해서(물론 `swagger`를 이용할 수도 있지만..) 사용한다면 `graphql`은 인스트로펙션을 통해 `graphql` 플레이그라운드에서 자동으로 작성된 문서를 보고 테스트해볼 수 있다는 장점이 있다.

## Graphql 쿼리어

`graphql`은 기존 `SQL`, `REST`와는 구문에서 차이가 있기 때문에 처음 봤을 때 해석에 어려움이 있었었다. 대표적인 `graphql`의 쿼리어를 비교하며 알아보자.

### Query

_- REST: GET_
_- SQL: SELECT_

`graphql`에서 데이터 요청을 보낼 때는 Query를 통해 데이터를 불러오게 된다.  사용예시는 아래와 같다. 받고싶은 데이터(필드)는 중괄호로 감싸서 요청을 하는데 이 중괄호로 묶인 블럭을 `Selection Set`라고 한다. 이러한 `Selection Set`는 서로 중첩시킬 수 있기 때문에 연관된 필요한 데이터만 가져올 수 있게 되는 것이다. 이래는 하나의 작업 뜻하는 `type`으로 미리 정의한`allIcecream`에서 `name`필드를 가져오는 것이다.

```
{
	allIcecream {
		name
	}
}
```

### Mutation

_- REST: POST, DELETE, PATCH_
_- SQL: INSERT, UPDATE, DELETE_

`graphql`에서는 `mutation`이라는 데이터 타입을 통해 데이터 조작을 한다. 데이터 조작시 필요한 데이터는 `mutation`과 함께 아래와 같이 전송하면 된다.

```
mutation {
	setIcecreamName(id: 3 name: "조아조아") {
		id
		name
	}
}
```

### Subscription

graphql은 API에 사용되는 쿼리어로서 소켓 연결로 전달되는 데이터 변경사항을 확인할 수 있는 `Subscription` 타입도 존재한다. 기존 SQL에서는 따로 존재하지 않는다. `Subscription`은 실시간 데이터 변경내용을 받을 수 있는 기능인데 마치 사람들이 '좋아요'버튼을 누른다고 가정하고 이를 실시간을 보여주고자 할 때 사용할 수 있다. 아래는 실시간으로 변하는 아이스크림의 수량을 확인하기위한 `subscription`이다.
```
Subscription {
	icecreamQuantityChange {
    	name
        quantity
    }
}
